## 二分查找

二分查找也称[折半查找]()（Binary Search），它是一种效率较高的查找方法。但是，**折半查找要求线性表必须采用顺序存储结构**，而且表中元素按关键字有序排列。

> 时间复杂度O(logn)
>
> 凡有序，必二分; 凡二分，时间复杂度必包含O(logn)



### 思路

1、递归

代码逻辑更加清晰



2、非递归（循环）

性能更好(相对来说)



![image-20220906162918328](https://qn.huat.xyz/mac/20220906162918.png)



### 代码

```ts
/**
 * 二分查找（递归）
 * @param arr arr
 * @param target target
 * @param startIndex start index
 * @param endIndex end index
 */
export function binarySearch2(
  arr: number[],
  target: number,
  startIndex?: number,
  endIndex?: number
): number {
  const length = arr.length
  if (length === 0) return -1

  // 开始和结束的范围
  if (startIndex == null) startIndex = 0
  if (endIndex == null) endIndex = length - 1

  // 如果 start 和 end 相遇，则结束
  if (startIndex > endIndex) return -1

  // 中间位置
  const midIndex = Math.floor((startIndex + endIndex) / 2)
  const midValue = arr[midIndex]

  if (target < midValue) {
    // 目标值较小，则继续在左侧查找
    return binarySearch2(arr, target, startIndex, midIndex - 1)
  } else if (target > midValue) {
    // 目标值较大，则继续在右侧查找
    return binarySearch2(arr, target, midIndex + 1, endIndex)
  } else {
    // 相等，返回
    return midIndex
  }
}



/**
 * 二分查找（循环）
 * @param arr arr
 * @param target target
 */
export function binarySearch1(arr: number[], target: number): number {
  const length = arr.length
  if (length === 0) return -1

  let startIndex = 0 // 开始位置
  let endIndex = length - 1 // 结束位置

  while (startIndex <= endIndex) {
    const midIndex = Math.floor((startIndex + endIndex) / 2)
    const midValue = arr[midIndex]
    if (target < midValue) {
      // 目标值较小，则继续在左侧查找
      endIndex = midIndex - 1
    } else if (target > midValue) {
      // 目标值较大，则继续在右侧查找
      startIndex = midIndex + 1
    } else {
      // 相等，返回
      return midIndex
    }
  }

  return -1
}
```



### 单测

```ts
// 路径自己处理
import { binarySearch1, binarySearch2 } from 'test'

describe('二分查找', () => {
  it('正常情况', () => {
    const arr = [10, 20, 30, 40, 50]
    const target = 40
    const index = binarySearch1(arr, target)
    expect(index).toBe(3)
  })

  it('空数组', () => {
    expect(binarySearch1([], 100)).toBe(-1)
  })

  it('找不到 target', () => {
    const arr = [10, 20, 30, 40, 50]
    const target = 400
    const index = binarySearch1(arr, target)
    expect(index).toBe(-1)
  })
})
```

