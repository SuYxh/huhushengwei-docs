import{o as e,c as o,b as l}from"./app.157864df.js";const d='{"title":"24 - Vue 3.0的设计目标是什么？做了哪些优化?","description":"","frontmatter":{},"headers":[{"level":2,"title":"24 - Vue 3.0的设计目标是什么？做了哪些优化?","slug":"_24-vue-3-0的设计目标是什么？做了哪些优化"},{"level":3,"title":"分析","slug":"分析"},{"level":3,"title":"思路","slug":"思路"},{"level":3,"title":"范例","slug":"范例"},{"level":3,"title":"可能的追问","slug":"可能的追问"}],"relativePath":"frame/vue/24 - Vue 3.0的设计目标是什么？做了哪些优化.md","lastUpdated":1662433250873}',i={},c=[l('<h2 id="_24-vue-3-0的设计目标是什么？做了哪些优化">24 - Vue 3.0的设计目标是什么？做了哪些优化?</h2><h3 id="分析">分析</h3><p>还是问新特性，陈述典型新特性，分析其给你带来的变化即可。</p><h3 id="思路">思路</h3><p>从以下几方面分门别类阐述：易用性、性能、扩展性、可维护性、开发体验等</p><hr><h3 id="范例">范例</h3><ol><li>Vue3的最大设计目标是替代Vue2（皮一下），为了实现这一点，Vue3在以下几个方面做了很大改进，如：易用性、框架性能、扩展性、可维护性、开发体验等</li><li>易用性方面主要是API简化，比如<code>v-model</code>在Vue3中变成了Vue2中<code>v-model</code>和<code>sync</code>修饰符的结合体，用户不用区分两者不同，也不用选择困难。类似的简化还有用于渲染函数内部生成VNode的<code>h(type, props, children)</code>，其中<code>props</code>不用考虑区分属性、特性、事件等，框架替我们判断，易用性大增。</li><li>开发体验方面，新组件<code>Teleport</code>传送门、<code>Fragments</code> 、<code>Suspense</code>等都会简化特定场景的代码编写，<code>SFC Composition API</code>语法糖更是极大提升我们开发体验。</li><li>扩展性方面提升如独立的<code>reactivity</code>模块，<code>custom renderer</code> API等</li><li>可维护性方面主要是<code>Composition API</code>，更容易编写高复用性的业务逻辑。还有对TypeScript支持的提升。</li><li>性能方面的改进也很显著，例如编译期优化、基于<code>Proxy</code>的响应式系统</li><li>。。。</li></ol><h3 id="可能的追问">可能的追问</h3><ol><li>Vue3做了哪些编译优化？</li><li><code>Proxy</code>和<code>defineProperty</code>有什么不同？</li></ol>',10)];i.render=function(l,d,i,t,r,u){return e(),o("div",null,c)};export default i;export{d as __pageData};
