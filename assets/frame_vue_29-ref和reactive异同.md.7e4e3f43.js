import{o as e,c as n,b as a}from"./app.157864df.js";const t='{"title":"29-ref和reactive异同","description":"","frontmatter":{},"headers":[{"level":2,"title":"29-ref和reactive异同","slug":"_29-ref和reactive异同"},{"level":3,"title":"体验","slug":"体验"},{"level":3,"title":"回答思路","slug":"回答思路"},{"level":3,"title":"回答范例","slug":"回答范例"},{"level":3,"title":"知其所以然","slug":"知其所以然"}],"relativePath":"frame/vue/29-ref和reactive异同.md","lastUpdated":1662433250873}',s={},o=[a('<h2 id="_29-ref和reactive异同">29-ref和reactive异同</h2><p>这是<code>Vue3</code>数据响应式中非常重要的两个概念，自然的，跟我们写代码关系也很大。</p><p>--</p><h3 id="体验">体验</h3><p>ref：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fvuejs.org%2Fapi%2Freactivity-core.html%23ref" target="_blank" rel="noopener noreferrer">vuejs.org/api/reactiv…</a></p><div class="language-js"><pre><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>\n\ncount<span class="token punctuation">.</span>value<span class="token operator">++</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>\n复制代码\n</code></pre></div><hr><p>reactive：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fvuejs.org%2Fapi%2Freactivity-core.html%23reactive" target="_blank" rel="noopener noreferrer">vuejs.org/api/reactiv…</a></p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\nobj<span class="token punctuation">.</span>count<span class="token operator">++</span>\n复制代码\n</code></pre></div><hr><h3 id="回答思路">回答思路</h3><ol><li>两者概念</li><li>两者使用场景</li><li>两者异同</li><li>使用细节</li><li>原理阐述</li></ol><hr><h3 id="回答范例">回答范例</h3><ol><li><code>ref</code>接收内部值（inner value）返回响应式<code>Ref</code>对象，<code>reactive</code>返回响应式代理对象</li><li>从定义上看<code>ref</code>通常用于处理单值响应式，<code>reactive</code>用于处理对象类型响应式</li><li>两者均用于构造响应式数据，但是<code>ref</code>主要解决原始值的响应式问题</li><li>ref返回的响应式数据在JS中使用需要加上<code>.value</code>才能访问其值，在视图中使用会自动脱<code>ref</code>，不需要<code>.value</code>；<code>ref</code>可以接收对象或数组等非原始值，但内部依然是<code>reactive</code>实现响应式；<code>reactive</code>内部如果接收<code>Ref</code>对象会自动脱<code>ref</code>；使用展开运算符(...)展开<code>reactive</code>返回的响应式对象会使其失去响应性，可以结合<code>toRefs()</code>将值转换为<code>Ref</code>对象之后再展开。</li><li><code>reactive</code>内部使用<code>Proxy</code>代理传入对象并拦截该对象各种操作（trap），从而实现响应式。<code>ref</code>内部封装一个<code>RefImpl</code>类，并设置存取器<code>get value/set value</code>，拦截用户对值的访问，从而实现响应式。</li></ol><hr><h3 id="知其所以然">知其所以然</h3><p>reactive实现响应式：</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Freactivity%2Fsrc%2Freactive.ts%23L90-L91" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p><p>ref实现响应式：</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Freactivity%2Fsrc%2Fref.ts%23L73-L74" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p>',21)];s.render=function(a,t,s,c,p,r){return e(),n("div",null,o)};export default s;export{t as __pageData};
