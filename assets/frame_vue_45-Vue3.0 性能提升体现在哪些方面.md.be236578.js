import{o as e,c as t,b as l}from"./app.157864df.js";const r='{"title":"Vue3.0 性能提升体现在哪些方面？","description":"","frontmatter":{},"headers":[{"level":2,"title":"Vue3.0 性能提升体现在哪些方面？","slug":"vue3-0-性能提升体现在哪些方面？"},{"level":3,"title":"分析","slug":"分析"},{"level":3,"title":"思路","slug":"思路"},{"level":3,"title":"回答范例","slug":"回答范例"},{"level":3,"title":"体验","slug":"体验"},{"level":3,"title":"知其所以然","slug":"知其所以然"}],"relativePath":"frame/vue/45-Vue3.0 性能提升体现在哪些方面.md","lastUpdated":1662083353135}',i={},a=[l('<h2 id="vue3-0-性能提升体现在哪些方面？">Vue3.0 性能提升体现在哪些方面？</h2><h3 id="分析">分析</h3><p>vue3在设计时有几个目标：更小、更快、更友好，这些多数适合性能相关，因此可以围绕介绍。</p><hr><h3 id="思路">思路</h3><ul><li>总述和性能相关的新特性</li><li>逐个说细节</li><li>能说点原理更佳</li></ul><hr><h3 id="回答范例">回答范例</h3><ul><li>我分别从代码、编译、打包三方面介绍vue3性能方面的提升</li><li>代码层面性能优化主要体现在全新响应式API，基于Proxy实现，初始化时间和内存占用均大幅改进；</li><li>编译层面做了更多编译优化处理，比如静态提升、动态标记、事件缓存，区块等，可以有效跳过大量diff过程；</li><li>打包时更好的支持tree-shaking，因此整体体积更小，加载更快</li></ul><hr><h3 id="体验">体验</h3><p>通过playground体验编译优化：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fsfc.vuejs.org" target="_blank" rel="noopener noreferrer">sfc.vuejs.org</a></p><p><img src="https://qn.huat.xyz/mac/20220829003833.awebp" alt="image-20220626184606427"></p><hr><h3 id="知其所以然">知其所以然</h3><p>为什么基于Proxy更快了：初始化时懒处理，用户访问才做拦截处理，初始化更快：</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Freactivity%2Fsrc%2FbaseHandlers.ts%23L136-L137" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p><p>轻量的依赖关系保存：利用WeakMap、Map和Set保存响应式数据和副作用之间的依赖关系</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Freactivity%2Fsrc%2Feffect.ts%23L19-L20" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p>',19)];i.render=function(l,r,i,s,u,p){return e(),t("div",null,a)};export default i;export{r as __pageData};
