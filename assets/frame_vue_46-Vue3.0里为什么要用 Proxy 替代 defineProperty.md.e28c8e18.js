import{o as n,c as a,b as s}from"./app.157864df.js";const e='{"title":"Vue3.0里为什么要用 Proxy 替代 defineProperty ？","description":"","frontmatter":{},"headers":[{"level":2,"title":"Vue3.0里为什么要用 Proxy 替代 defineProperty ？","slug":"vue3-0里为什么要用-proxy-替代-defineproperty-？"},{"level":3,"title":"分析","slug":"分析"},{"level":3,"title":"思路","slug":"思路"},{"level":3,"title":"回答范例","slug":"回答范例"},{"level":3,"title":"知其所以然","slug":"知其所以然"}],"relativePath":"frame/vue/46-Vue3.0里为什么要用 Proxy 替代 defineProperty.md","lastUpdated":1662083353135}',t={},p=[s('<h2 id="vue3-0里为什么要用-proxy-替代-defineproperty-？">Vue3.0里为什么要用 Proxy 替代 defineProperty ？</h2><h3 id="分析">分析</h3><p>Vue3中最重大的更新之一就是响应式模块<code>reactivity</code>的重写。主要的修改就是<code>Proxy</code>替换<code>defineProperty</code>实现响应式。</p><p>此变化主要是从性能方面考量。</p><h3 id="思路">思路</h3><ul><li>属性拦截的几种方式</li><li>defineProperty的问题</li><li>Proxy的优点</li><li>其他考量</li></ul><h3 id="回答范例">回答范例</h3><ul><li>JS中做属性拦截常见的方式有三：: <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FdefineProperty" target="_blank" rel="noopener noreferrer">defineProperty</a>，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2Fget" target="_blank" rel="noopener noreferrer">getter</a>/<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2Fset" target="_blank" rel="noopener noreferrer">setters</a> 和<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FProxy" target="_blank" rel="noopener noreferrer">Proxies</a>.</li><li>Vue2中使用<code>defineProperty</code>的原因是，2013年时只能用这种方式。由于该API存在一些局限性，比如对于数组的拦截有问题，为此vue需要专门为数组响应式做一套实现。另外不能拦截那些新增、删除属性；最后<code>defineProperty</code>方案在初始化时需要深度递归遍历待处理的对象才能对它进行完全拦截，明显增加了初始化的时间。</li><li>以上两点在Proxy出现之后迎刃而解，不仅可以对数组实现拦截，还能对Map、Set实现拦截；另外Proxy的拦截也是懒处理行为，如果用户没有访问嵌套对象，那么也不会实施拦截，这就让初始化的速度和内存占用都改善了。</li><li>当然Proxy是有兼容性问题的，IE完全不支持，所以如果需要IE兼容就不合适</li></ul><h3 id="知其所以然">知其所以然</h3><p>Proxy属性拦截的原理：利用get、set、deleteProperty这三个trap实现拦截</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>Object.defineProperty属性拦截原理：利用get、set这两个trap实现拦截</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    Object<span class="token punctuation">.</span><span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n        <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>很容易看出两者的区别！</p>',14)];t.render=function(s,e,t,o,c,l){return n(),a("div",null,p)};export default t;export{e as __pageData};
