import{o as n,c as s,b as a}from"./app.157864df.js";const t='{"title":"HTTP 请求跨域问题","description":"","frontmatter":{},"headers":[{"level":3,"title":"HTTP 请求跨域问题","slug":"http-请求跨域问题"}],"relativePath":"network/http/2.HTTP 请求跨域问题.md","lastUpdated":1662433250873}',p={},o=[a('<h3 id="http-请求跨域问题">HTTP 请求跨域问题</h3><ol><li><p>跨域的原理</p><p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。 <strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。 <strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p></li><li><p>解决方案</p><p>最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()</p><ul><li><p><strong>JSONP</strong>： ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p><p>步骤：</p><ol><li><p>去创建一个script标签</p></li><li><p>script的src属性设置接口地址</p></li><li><p>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</p></li><li><p>通过定义函数名去接受返回的数据</p><div class="language-js"><pre><code><span class="token comment">//动态创建 script</span>\n<span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&#39;script&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 设置回调函数</span>\n<span class="token keyword">function</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">//设置 script 的 src 属性，并设置请求地址</span>\nscript<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&#39;http://localhost:3000/?callback=getData&#39;</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 让 script 生效</span>\ndocument<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div></li></ol></li></ul></li></ol><p><strong>JSONP 的缺点</strong>: JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p><ul><li><strong>document.domain</strong> 基础域名相同 子域名不同</li><li><strong><a href="http://window.name" target="_blank" rel="noopener noreferrer">window.name</a></strong> 利用在一个浏览器窗口内，<a href="http://xn--window-9m7igl23bo8p1d816aimn1m9awlmujd5y9gz67ew7f.name" target="_blank" rel="noopener noreferrer">载入所有的域名都是共享一个window.name</a></li><li><strong>CORS</strong> CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</li><li><strong>proxy代理</strong> 目前常用方式,通过服务器设置代理</li><li><strong>window.postMessage()</strong> 利用h5新特性window.postMessage()</li></ul><p>跨域传送门 ☞ <a href="https://juejin.cn/post/7003232769182547998" target="_blank" rel="noopener noreferrer"># 跨域，不可不知的基础概念</a></p>',5)];p.render=function(a,t,p,e,c,r){return n(),s("div",null,o)};export default p;export{t as __pageData};
