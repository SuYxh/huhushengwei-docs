import{o as e,c as t,b as o}from"./app.157864df.js";const l='{"title":"var && let && const","description":"","frontmatter":{},"headers":[{"level":3,"title":"var && let && const","slug":"var-let-const"}],"relativePath":"guide/js/3.var && let && const.md","lastUpdated":1662083353139}',a={},n=[o('<h3 id="var-let-const">var &amp;&amp; let &amp;&amp; const</h3><p>ES6之前创建变量用的是var,之后创建变量用的是let/const</p><p><strong>三者区别</strong>：</p><ol><li>var定义的变量，<code>没有块的概念，可以跨块访问</code>, 不能跨函数访问。 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。</li><li>var可以<code>先使用，后声明</code>，因为存在变量提升；let必须先声明后使用。</li><li>var是允许在相同作用域内<code>重复声明同一个变量</code>的，而let与const不允许这一现象。</li><li>在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ; var声明的变量会和GO有映射关系；</li><li><code>会产生暂时性死区</code>：</li></ol><blockquote><p>暂时性死区是浏览器的bug：检测一个未被声明的变量类型时，不会报错，会返回undefined 如：console.log(typeof a) //undefined 而：console.log(typeof a)//未声明之前不能使用 let a</p></blockquote><ol><li>let /const/function会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于let的块作用特征即可解决</li></ol>',6)];a.render=function(o,l,a,c,i,r){return e(),t("div",null,n)};export default a;export{l as __pageData};
