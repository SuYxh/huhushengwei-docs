import{o as n,c as a,b as s}from"./app.157864df.js";const t='{"title":"18-怎么缓存当前的组件？缓存后怎么更新？","description":"","frontmatter":{},"headers":[{"level":2,"title":"18-怎么缓存当前的组件？缓存后怎么更新？","slug":"_18-怎么缓存当前的组件？缓存后怎么更新？"},{"level":3,"title":"思路","slug":"思路"},{"level":3,"title":"回答范例","slug":"回答范例"},{"level":3,"title":"知其所以然","slug":"知其所以然"},{"level":2,"title":"","slug":""}],"relativePath":"frame/vue/18-怎么缓存当前的组件？缓存后怎么更新？.md","lastUpdated":1662433250869}',e={},p=[s('<h2 id="_18-怎么缓存当前的组件？缓存后怎么更新？">18-怎么缓存当前的组件？缓存后怎么更新？</h2><p>缓存组件使用keep-alive组件，这是一个非常常见且有用的优化手段，vue3中keep-alive有比较大的更新，能说的点比较多。</p><h3 id="思路">思路</h3><ol><li>缓存用keep-alive，它的作用与用法</li><li>使用细节，例如缓存指定/排除、结合router和transition</li><li>组件缓存后更新可以利用activated或者beforeRouteEnter</li><li>原理阐述</li></ol><hr><h3 id="回答范例">回答范例</h3><ol><li><p>开发中缓存组件使用keep-alive组件，keep-alive是vue内置组件，keep-alive包裹动态组件component时，会缓存不活动的组件实例，而不是销毁它们，这样在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p><div class="language-vue"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>view<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>\n复制代码\n</code></pre></div></li><li><p>结合属性include和exclude可以明确指定缓存哪些组件或排除缓存指定组件。vue3中结合vue-router时变化较大，之前是<code>keep-alive</code>包裹<code>router-view</code>，现在需要反过来用<code>router-view</code>包裹<code>keep-alive</code>：</p><div class="language-vue"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">v-slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ Component }<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Component<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span>\n复制代码\n</code></pre></div></li></ol><hr><ol><li><p>缓存后如果要获取数据，解决方案可以有以下两种：</p><ul><li><p>beforeRouteEnter：在有vue-router的项目，每次进入路由的时候，都会执行<code>beforeRouteEnter</code></p><div class="language-js"><pre><code><span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>\n    <span class="token comment">// 每次进入路由执行</span>\n    vm<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 获取数据</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n复制代码\n</code></pre></div></li><li><p>actived：在<code>keep-alive</code>缓存的组件被激活的时候，都会执行<code>actived</code>钩子</p><div class="language-js"><pre><code><span class="token function">activated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n\t  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 获取数据</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n复制代码\n</code></pre></div></li></ul></li></ol><hr><ol><li>keep-alive是一个通用组件，它内部定义了一个map，缓存创建过的组件实例，它返回的渲染函数内部会查找内嵌的component组件对应组件的vnode，如果该组件在map中存在就直接返回它。由于component的is属性是个响应式数据，因此只要它变化，keep-alive的render函数就会重新执行。</li></ol><hr><h3 id="知其所以然">知其所以然</h3><p>KeepAlive定义</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Fruntime-core%2Fsrc%2Fcomponents%2FKeepAlive.ts%23L73-L74" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p><p>缓存定义</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Fruntime-core%2Fsrc%2Fcomponents%2FKeepAlive.ts%23L102-L103" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p><p>缓存组件</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Fruntime-core%2Fsrc%2Fcomponents%2FKeepAlive.ts%23L215-L216" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p><p>获取缓存组件</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Fruntime-core%2Fsrc%2Fcomponents%2FKeepAlive.ts%23L241-L242" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p><p>测试缓存特性，test-v3.html</p><hr><h2 id=""></h2>',24)];e.render=function(s,t,e,o,c,l){return n(),a("div",null,p)};export default e;export{t as __pageData};
