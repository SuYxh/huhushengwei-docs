import{o as e,c as t,b as r}from"./app.157864df.js";const o='{"title":"09 - 说说你对虚拟 DOM 的理解？","description":"","frontmatter":{},"headers":[{"level":2,"title":"09 - 说说你对虚拟 DOM 的理解？","slug":"_09-说说你对虚拟-dom-的理解？"},{"level":3,"title":"分析","slug":"分析"},{"level":3,"title":"思路","slug":"思路"},{"level":3,"title":"回答范例","slug":"回答范例"},{"level":3,"title":"知其所以然","slug":"知其所以然"},{"level":2,"title":"","slug":""}],"relativePath":"frame/vue/09 - 说说你对虚拟 DOM 的理解？.md","lastUpdated":1662083353135}',l={},i=[r('<h2 id="_09-说说你对虚拟-dom-的理解？">09 - 说说你对虚拟 DOM 的理解？</h2><h3 id="分析">分析</h3><p>现有框架几乎都引入了虚拟 DOM 来对真实 DOM 进行抽象，也就是现在大家所熟知的 VNode 和 VDOM，那么为什么需要引入虚拟 DOM 呢？围绕这个疑问来解答即可！</p><h3 id="思路">思路</h3><ol><li>vdom是什么</li><li>引入vdom的好处</li><li>vdom如何生成，又如何成为dom</li><li>在后续的diff中的作用</li></ol><hr><h3 id="回答范例">回答范例</h3><ol><li><p>虚拟dom顾名思义就是虚拟的dom对象，它本身就是一个 <code>JavaScript</code> 对象，只不过它是通过不同的属性去描述一个视图结构。</p></li><li><p>通过引入vdom我们可以获得如下好处：</p><p><strong>将真实元素节点抽象成 VNode，有效减少直接操作 dom 次数，从而提高程序性能</strong></p><ul><li>直接操作 dom 是有限制的，比如：diff、clone 等操作，一个真实元素上有许多的内容，如果直接对其进行 diff 操作，会去额外 diff 一些没有必要的内容；同样的，如果需要进行 clone 那么需要将其全部内容进行复制，这也是没必要的。但是，如果将这些操作转移到 JavaScript 对象上，那么就会变得简单了。</li><li>操作 dom 是比较昂贵的操作，频繁的dom操作容易引起页面的重绘和回流，但是通过抽象 VNode 进行中间处理，可以有效减少直接操作dom的次数，从而减少页面重绘和回流。</li></ul><p><strong>方便实现跨平台</strong></p><ul><li>同一 VNode 节点可以渲染成不同平台上的对应的内容，比如：渲染在浏览器是 dom 元素节点，渲染在 Native( iOS、Android) 变为对应的控件、可以实现 SSR 、渲染到 WebGL 中等等</li><li>Vue3 中允许开发者基于 VNode 实现自定义渲染器（renderer），以便于针对不同平台进行渲染。</li></ul></li></ol><hr><ol><li><p>vdom如何生成？在vue中我们常常会为组件编写模板 - template， 这个模板会被编译器 - compiler编译为渲染函数，在接下来的挂载（mount）过程中会调用render函数，返回的对象就是虚拟dom。但它们还不是真正的dom，所以会在后续的patch过程中进一步转化为dom。</p><p><img src="https://qn.huat.xyz/mac/20220828184018.awebp" alt="image-20220209153820845"></p></li><li><p>挂载过程结束后，vue程序进入更新流程。如果某些响应式数据发生变化，将会引起组件重新render，此时就会生成新的vdom，和上一次的渲染结果diff就能得到变化的地方，从而转换为最小量的dom操作，高效更新视图。</p></li></ol><hr><h3 id="知其所以然">知其所以然</h3><p>vnode定义：</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Fruntime-core%2Fsrc%2Fvnode.ts%23L127-L128" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p><p>观察渲染函数：21-vdom/test-render-v3.html</p><p>创建vnode：</p><ul><li>createElementBlock:</li></ul><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Fruntime-core%2Fsrc%2Fvnode.ts%23L291-L292" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p><ul><li>createVnode:</li></ul><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Fruntime-core%2Fsrc%2Fvnode.ts%23L486-L487" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p><ul><li>首次调用时刻：</li></ul><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Fruntime-core%2Fsrc%2FapiCreateApp.ts%23L283-L284" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p><hr><p>mount:</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fvuejs%2Fcore%2Fblob%2FHEAD%2Fpackages%2Fruntime-core%2Fsrc%2Frenderer.ts%23L1171-L1172" target="_blank" rel="noopener noreferrer">github1s.com/vuejs/core/…</a></p><p>调试mount过程：mountComponent</p><p>21-vdom/test-render-v3.html</p><hr><h2 id=""></h2>',29)];l.render=function(r,o,l,p,n,s){return e(),t("div",null,i)};export default l;export{o as __pageData};
