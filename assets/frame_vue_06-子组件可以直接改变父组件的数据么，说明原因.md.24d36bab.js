import{o as n,c as s,b as a}from"./app.157864df.js";const p='{"title":"06-子组件可以直接改变父组件的数据么，说明原因","description":"","frontmatter":{},"headers":[{"level":2,"title":"06-子组件可以直接改变父组件的数据么，说明原因","slug":"_06-子组件可以直接改变父组件的数据么，说明原因"},{"level":3,"title":"分析","slug":"分析"},{"level":3,"title":"思路","slug":"思路"},{"level":3,"title":"回答范例","slug":"回答范例"},{"level":2,"title":"","slug":""}],"relativePath":"frame/vue/06-子组件可以直接改变父组件的数据么，说明原因.md","lastUpdated":1662083353135}',t={},o=[a('<h2 id="_06-子组件可以直接改变父组件的数据么，说明原因">06-子组件可以直接改变父组件的数据么，说明原因</h2><h3 id="分析">分析</h3><p>这是一个实践知识点，组件化开发过程中有个<strong>单项数据流原则</strong>，不在子组件中修改父组件是个常识问题。</p><p>参考文档：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fstaging.vuejs.org%2Fguide%2Fcomponents%2Fprops.html%23one-way-data-flow" target="_blank" rel="noopener noreferrer">staging.vuejs.org/guide/compo…</a></p><hr><h3 id="思路">思路</h3><ol><li>讲讲单项数据流原则，表明为何不能这么做</li><li>举几个常见场景的例子说说解决方案</li><li>结合实践讲讲如果需要修改父组件状态应该如何做</li></ol><hr><h3 id="回答范例">回答范例</h3><ol><li><p>所有的 prop 都使得其父子之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。另外，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器控制台中发出警告。</p><div class="language-ini"><pre><code><span class="token key attr-name">const props</span> <span class="token punctuation">=</span> <span class="token value attr-value">defineProps([&#39;foo&#39;])</span>\n// ❌ 下面行为会被警告, props是只读的!\n<span class="token key attr-name">props.foo</span> <span class="token punctuation">=</span> <span class="token value attr-value">&#39;<span class="token inner-value">bar</span>&#39;</span>\n</code></pre></div></li></ol><hr><ol><li><p>实际开发过程中有两个场景会想要修改一个属性：</p><ul><li><p>**这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。**在这种情况下，最好定义一个本地的 data，并将这个 prop 用作其初始值：</p><div class="language-js"><pre><code><span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token function">defineProps</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;initialCounter&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>initialCounter<span class="token punctuation">)</span>\n</code></pre></div></li><li><p>**这个 prop 以一种原始的值传入且需要进行转换。**在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p><div class="language-js"><pre><code><span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token function">defineProps</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;size&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token comment">// prop变化，计算属性自动更新</span>\n<span class="token keyword">const</span> normalizedSize <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> props<span class="token punctuation">.</span>size<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre></div></li></ul></li><li><p>实践中如果确实想要改变父组件属性应该emit一个事件让父组件去做这个变更。注意虽然我们不能直接修改一个传入的对象或者数组类型的prop，但是我们还是能够直接改内嵌的对象或属性。</p></li></ol><hr><h2 id=""></h2>',14)];t.render=function(a,p,t,e,l,c){return n(),s("div",null,o)};export default t;export{p as __pageData};
