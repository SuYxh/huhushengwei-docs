<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript 数据结构与算法（十三）二叉搜索树 | Huhushengwei</title>
    <meta name="description" content="Life is short, Keep it simple.">
    <link rel="stylesheet" href="/huhushengwei-docs/assets/style.fd287066.css">
    <link rel="modulepreload" href="/huhushengwei-docs/assets/Home.bbac2f7b.js">
    <link rel="modulepreload" href="/huhushengwei-docs/assets/AlgoliaSearchBox.17507194.js">
    <link rel="modulepreload" href="/huhushengwei-docs/assets/app.157864df.js">
    <link rel="modulepreload" href="/huhushengwei-docs/assets/algorithm_dataStructure_tree_二叉搜索树.md.75134e03.lean.js">
    <link rel="modulepreload" href="/huhushengwei-docs/assets/app.157864df.js">
    <link rel="icon" type="image/svg+xml" href="/logo.svg">
    <meta name="twitter:title" content="JavaScript 数据结构与算法（十三）二叉搜索树 | Huhushengwei">
    <meta property="og:title" content="JavaScript 数据结构与算法（十三）二叉搜索树 | Huhushengwei">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/huhushengwei-docs/" aria-label="Huhushengwei, back to home" data-v-675d8756 data-v-4a583abe><img class="logo" src="/huhushengwei-docs/logo.svg" alt="Logo" data-v-4a583abe> Huhushengwei</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/guide/" data-v-b8818f8c>基础 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/frame/" data-v-b8818f8c>框架 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/workflow/" data-v-b8818f8c>工程化 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/network/" data-v-b8818f8c>网络 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item active" href="/huhushengwei-docs/algorithm/" data-v-b8818f8c>算法 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/performance/" data-v-b8818f8c>性能优化 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/devTool/" data-v-b8818f8c>工具 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/other/" data-v-b8818f8c>其他 <!----></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--[--><div class="algolia-search-box" id="docsearch"></div><!--]--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-15acbf05><!--[--><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/guide/" data-v-b8818f8c>基础 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/frame/" data-v-b8818f8c>框架 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/workflow/" data-v-b8818f8c>工程化 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/network/" data-v-b8818f8c>网络 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item active" href="/huhushengwei-docs/algorithm/" data-v-b8818f8c>算法 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/performance/" data-v-b8818f8c>性能优化 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/devTool/" data-v-b8818f8c>工具 <!----></a></div></div><div class="item" data-v-15acbf05><div class="nav-link" data-v-15acbf05 data-v-b8818f8c><a class="item" href="/huhushengwei-docs/other/" data-v-b8818f8c>其他 <!----></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><p class="sidebar-link-item">数据结构</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/dataStructure/stack/1.栈">栈</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/dataStructure/queue/队列">队列</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/dataStructure/queue/优先队列">优先队列</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/dataStructure/linkList/单向链表">单向链表</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/dataStructure/linkList/双向链表">双向链表</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/dataStructure/tree/树">树</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/dataStructure/tree/二叉树">二叉树</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/huhushengwei-docs/algorithm/dataStructure/tree/二叉搜索树">二叉搜索树</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#二叉搜索树">二叉搜索树</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#二叉搜索树应用举例">二叉搜索树应用举例</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#二叉搜索树的封装">二叉搜索树的封装</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#二叉搜索树的常见操作：">二叉搜索树的常见操作：</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#平衡树">平衡树</a><!----></li></ul></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">排序</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/search/1.冒泡排序">1.冒泡排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/search/2.二分查找">2.二分查找</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/search/3.插入排序">3.插入排序</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/search/4.快速排序">4.快速排序</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">数组</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/array/two-numbers-sum">两数之和</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">栈</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/stack/用两个栈实现一个队列">用两个栈实现一个队列</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">链表</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/huhushengwei-docs/algorithm/linkList/JS反转单向链表">JS反转单向链表</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h1 id="javascript-数据结构与算法（十三）二叉搜索树">JavaScript 数据结构与算法（十三）二叉搜索树</h1><h2 id="二叉搜索树">二叉搜索树</h2><p>二叉搜索树（BST，Binary Search Tree），也称为二叉排序树和二叉查找树。</p><p>二叉搜索树是一棵二叉树，可以为空。</p><p>如果不为空，则满足以下性质：</p><ul><li>条件 1：非空左子树的所有键值小于其根节点的键值。比如三中节点 6 的所有非空左子树的键值都小于 6；</li><li>条件 2：非空右子树的所有键值大于其根节点的键值；比如三中节点 6 的所有非空右子树的键值都大于 6；</li><li>条件 3：左、右子树本身也都是二叉搜索树；</li></ul><p><img src="https://qn.huat.xyz/mac/20220829104356.png" alt="image"></p><p>如上图所示，树二和树三符合 3 个条件属于二叉树，树一不满足条件 3 所以不是二叉树。</p><p>总结：二叉搜索树的特点主要是较小的值总是保存在左节点上，相对较大的值总是保存在右节点上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中“搜索”的来源。</p><h2 id="二叉搜索树应用举例">二叉搜索树应用举例</h2><p>下面是一个二叉搜索树：</p><p><img src="https://qn.huat.xyz/mac/20220829104357.png" alt="image"></p><p>若想在其中查找数据 10，只需要查找 4 次，查找效率非常高。</p><ul><li>第 1 次：将 10 与根节点 9 进行比较，由于 10 &gt; 9，所以 10 下一步与根节点 9 的右子节点 13 比较；</li><li>第 2 次：由于 10 &lt; 13，所以 10 下一步与父节点 13 的左子节点 11 比较；</li><li>第 3 次：由于 10 &lt; 11，所以 10 下一步与父节点 11 的左子节点 10 比较；</li><li>第 4 次：由于 10 = 10，最终查找到数据 10 。</li></ul><p><img src="https://qn.huat.xyz/mac/20220829104400.png" alt="image"></p><p>同样是 15 个数据，在排序好的数组中查询数据 10，需要查询 10 次：</p><p><img src="https://qn.huat.xyz/mac/20220829104401.png" alt="image"></p><p>其实：如果是排序好的数组，可以通过二分查找：第一次找 9，第二次找 13，第三次找 15...。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树。这就是数组二分法查找效率之所以高的原因。</p><h2 id="二叉搜索树的封装">二叉搜索树的封装</h2><p>二叉搜索树有四个最基本的属性：指向节点的根（root），节点中的键（key）、左指针（right）、右指针（right）。</p><p><img src="https://qn.huat.xyz/mac/20220829104402.png" alt="image"></p><p>所以，二叉搜索树中除了定义 root 属性外，还应定义一个节点内部类，里面包含每个节点中的 left、right 和 key 三个属性。</p><div class="language-js"><pre><code><span class="token comment">// 节点类</span>
<span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="二叉搜索树的常见操作：">二叉搜索树的常见操作：</h3><ul><li><code>insert(key)</code> 向树中插入一个新的键。</li><li><code>search(key)</code> 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 <code>false</code>。</li><li><code>preOrderTraverse</code> 通过先序遍历方式遍历所有节点。</li><li><code>inOrderTraverse</code> 通过中序遍历方式遍历所有节点。</li><li><code>postOrderTraverse</code> 通过后序遍历方式遍历所有节点。</li><li><code>min</code> 返回树中最小的值/键。</li><li><code>max</code> 返回树中最大的值/键。</li><li><code>remove(key)</code> 从树中移除某个键。</li></ul><h4 id="插入数据">插入数据</h4><p>实现思路：</p><ul><li>首先根据传入的 key 创建节点对象。</li><li>然后判断根节点是否存在，不存在时通过：this.root = newNode，直接把新节点作为二叉搜索树的根节点。</li><li>若存在根节点则重新定义一个内部方法 <code>insertNode()</code> 用于查找插入点。</li></ul><p>insert(key) 代码实现</p><div class="language-js"><pre><code><span class="token comment">// insert(key) 插入数据</span>
<span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>insertNode() 的实现思路:</p><p>根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。</p><ul><li><p>当 newNode.key &lt; node.key 向左查找:</p><ul><li><p>情况 1：当 node 无左子节点时，直接插入：</p></li><li><p>情况 2：当 node 有左子节点时，递归调用 insertNode()，直到遇到无左子节点成功插入 newNode 后，不再符合该情况，也就不再调用 insertNode()，递归停止。</p></li></ul></li><li><p>当 newNode.key &gt;= node.key 向右查找，与向左查找类似：</p><ul><li><p>情况 1：当 node 无右子节点时，直接插入：</p></li><li><p>情况 2：当 node 有右子节点时，依然递归调用 insertNode()，直到遇到传入 insertNode 方法 的 node 无右子节点成功插入 newNode 为止。</p></li></ul></li></ul><p>insertNode(root, node) 代码实现</p><div class="language-js"><pre><code><span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 往左边查找插入</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      root<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 往右边查找插入</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      root<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h4 id="遍历数据">遍历数据</h4><p>这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：</p><ul><li>先序遍历；</li><li>中序遍历；</li><li>后序遍历；</li></ul><p>还有层序遍历，使用较少。</p><h5 id="先序遍历">先序遍历</h5><p>先序遍历的过程为：</p><p>首先，遍历根节点； 然后，遍历其左子树； 最后，遍历其右子树；</p><p><img src="https://qn.huat.xyz/mac/20220829104403.png" alt="image"></p><p>如上图所示，二叉树的节点遍历顺序为：A -&gt; B -&gt; D -&gt; H -&gt; I -&gt; E -&gt; C -&gt; F -&gt; G。</p><p>代码实现：</p><div class="language-js"><pre><code><span class="token comment">// 先序遍历（根左右 DLR）</span>
<span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preorderTraversalNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">preorderTraversalNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="中序遍历">中序遍历</h5><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p><p>首先，遍历其左子树； 然后，遍历根（父）节点； 最后，遍历其右子树；</p><p>过程图解：</p><p><img src="https://qn.huat.xyz/mac/20220829104404.png" alt="image"></p><p>输出节点的顺序应为：3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 14 -&gt; 15 -&gt; 18 -&gt; 20 -&gt; 25 。</p><p>代码实现：</p><div class="language-js"><pre><code><span class="token comment">// 中序遍历（左根右 LDR）</span>
<span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inorderTraversalNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">inorderTraversalNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="后序遍历">后序遍历</h5><p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p><p>首先，遍历其左子树； 然后，遍历其右子树； 最后，遍历根（父）节点；</p><p>过程图解：</p><p><img src="https://qn.huat.xyz/mac/20220829104405.png" alt="image"></p><p>输出节点的顺序应为：3 -&gt; 6 -&gt; 5 -&gt; 8 -&gt; 10 -&gt; 9 -&gt; 7 -&gt; 12 -&gt; 14 -&gt; 13 -&gt; 18 -&gt; 25 -&gt; 20 -&gt; 15 -&gt; 11 。</p><p>代码实现：</p><div class="language-js"><pre><code><span class="token comment">// 后序遍历（左右根 LRD）</span>
<span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postorderTraversalNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">postorderTraversalNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="总结">总结</h5><p>以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。</p><h4 id="查找数据">查找数据</h4><h5 id="查找最大值或最小值">查找最大值或最小值</h5><p>在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如下图所示：</p><p><img src="https://qn.huat.xyz/mac/20220829104406.png" alt="image"></p><p>代码实现：</p><div class="language-js"><pre><code><span class="token comment">// min() 获取二叉搜索树最小值</span>
<span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> node<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// max() 获取二叉搜索树最大值</span>
<span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> node<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="查找特定值">查找特定值</h5><p>查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的 key 值与之比较，若 node.key &lt; root 则向左查找，若 node.key &gt; root 就向右查找，直到找到或查找到 null 为止。这里可以使用递归实现，也可以采用循环来实现。</p><p>代码实现：</p><div class="language-js"><pre><code><span class="token comment">// search(key) 查找二叉搜索树中是否有相同的key，存在返回 true，否则返回 false</span>
<span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 通过递归实现</span>
<span class="token function">searchNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 通过 while 循环实现</span>
<span class="token function">search2</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h4 id="删除数据">删除数据</h4><p>实现思路：</p><p>第一步：先找到需要删除的节点，若没找到，则不需要删除；</p><p>首先定义变量 current 用于保存需要删除的节点、变量 parent 用于保存它的父节点、变量 isLeftChild 保存 current 是否为 parent 的左节点，这样方便之后删除节点时改变相关节点的指向。</p><div class="language-js"><pre><code><span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
<span class="token keyword">let</span> parentNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> isLeftChild <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token comment">// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>key <span class="token operator">!==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  parentNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>

  <span class="token comment">// 小于，往左查找</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> currentNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isLeftChild <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则往右查找</span>
    isLeftChild <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 找到最后都没找到相等的节点，返回 false</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>第二步：删除找到的指定节点，后分 3 种情况：</p><ul><li>删除的是叶子节点；</li><li>删除的是只有一个子节点的节点；</li><li>删除的是有两个子节点的节点；</li></ul><h5 id="删除的是叶子节点">删除的是叶子节点</h5><p>删除的是叶子节点分两种情况：</p><ul><li><p>叶子节点也是根节点</p><p>当该叶子节点为根节点时，如下图所示，此时 current == this.root，直接通过：this.root = null，删除根节点。</p><p><img src="https://qn.huat.xyz/mac/20220829104407.png" alt="image"></p></li><li><p>叶子节点不为根节点</p><p>当该叶子节点不为根节点时也有两种情况，如下图所示</p><p><img src="https://qn.huat.xyz/mac/20220829104408.png" alt="image"></p><p>若 current = 8，可以通过：parent.left = null，删除节点 8；</p><p>若 current = 10，可以通过：parent.right = null，删除节点 10；</p><p>代码实现：</p><div class="language-js"><pre><code><span class="token comment">// 1、删除的是叶子节点的情况</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> currentNode<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 2、删除的是只有一个子节点的节点</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul><h5 id="删除的是只有一个子节点的节点">删除的是只有一个子节点的节点</h5><p>有六种情况：</p><p>当 current 存在左子节点时（current.right == null）：</p><ul><li><p>情况 1：current 为根节点（current == this.root），如节点 11，此时通过：this.root = current.left，删除根节点 11；</p></li><li><p>情况 2：current 为父节点 parent 的左子节点（isLeftChild == true），如节点 5，此时通过：parent.left = current.left，删除节点 5；</p></li><li><p>情况 3：current 为父节点 parent 的右子节点（isLeftChild == false），如节点 9，此时通过：parent.right = current.left，删除节点 9；</p></li></ul><p><img src="https://qn.huat.xyz/mac/20220829104409.png" alt="image"></p><p>当 current 存在右子节点时（current.left = null）：</p><ul><li><p>情况 4：current 为根节点（current == this.root），如节点 11，此时通过：this.root = current.right，删除根节点 11。</p></li><li><p>情况 5：current 为父节点 parent 的左子节点（isLeftChild == true），如节点 5，此时通过：parent.left = current.right，删除节点 5；</p></li><li><p>情况 6：current 为父节点 parent 的右子节点（isLeftChild == false），如节点 9，此时通过：parent.right = current.right，删除节点 9；</p></li></ul><p><img src="https://qn.huat.xyz/mac/20220829104411.png" alt="image"></p><p>代码实现：</p><div class="language-js"><pre><code><span class="token comment">// 2、删除的是只有一个子节点的节点</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// currentNode 只存在左节点</span>
  <span class="token comment">//-- 2.1、currentNode 只存在&lt;左节点&gt;的情况</span>
  <span class="token comment">//---- 2.1.1、currentNode 等于 root</span>
  <span class="token comment">//---- 2.1.2、parentNode.left 等于 currentNode</span>
  <span class="token comment">//---- 2.1.3、parentNode.right 等于 currentNode</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// currentNode 只存在右节点</span>
  <span class="token comment">//-- 2.2、currentNode 只存在&lt;右节点&gt;的情况</span>
  <span class="token comment">//---- 2.1.1 currentNode 等于 root</span>
  <span class="token comment">//---- 2.1.1 parentNode.left 等于 currentNode</span>
  <span class="token comment">//---- 2.1.1 parentNode.right 等于 currentNode</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="删除的是有两个子节点的节点">删除的是有两个子节点的节点</h5><p>这种情况十分复杂，首先依据以下二叉搜索树，讨论这样的问题：</p><p><img src="https://qn.huat.xyz/mac/20220829104412.png" alt="image"></p><p><strong>删除节点 9</strong></p><p>在保证删除节点 9 后原二叉树仍为二叉搜索树的前提下，有两种方式：</p><ul><li>方式 1：从节点 9 的左子树中选择一合适的节点替代节点 9，可知节点 8 符合要求；</li><li>方式 2：从节点 9 的右子树中选择一合适的节点替代节点 9，可知节点 10 符合要求；</li></ul><p><img src="https://qn.huat.xyz/mac/20220829104414.png" alt="image"></p><p><strong>删除节点 7</strong></p><p>在保证删除节点 7 后原二叉树仍为二叉搜索树的前提下，也有两种方式：</p><ul><li>方式 1：从节点 7 的左子树中选择一合适的节点替代节点 7，可知节点 5 符合要求；</li><li>方式 2：从节点 7 的右子树中选择一合适的节点替代节点 7，可知节点 8 符合要求；</li></ul><p><img src="https://qn.huat.xyz/mac/20220829104415.png" alt="image"></p><p><strong>删除节点 15</strong></p><p>在保证删除节点 15 后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：</p><ul><li>方式 1：从节点 15 的左子树中选择一合适的节点替代节点 15，可知节点 14 符合要求；</li><li>方式 2：从节点 15 的右子树中选择一合适的节点替代节点 15，可知节点 18 符合要求；</li></ul><p><img src="https://qn.huat.xyz/mac/20220829104417.png" alt="image"></p><p>相信你已经发现其中的规律了！</p><p>规律总结：如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点下面的子节点中找到一个合适的节点，来替换当前的节点。</p><p>若用 current 表示需要删除的节点，则合适的节点指的是：</p><ul><li>current 左子树中比 current 小一点点的节点，即 current 左子树中的最大值；</li><li>current 右子树中比 current 大一点点的节点，即 current 右子树中的最小值；</li></ul><h6 id="前驱-后继">前驱&amp;后继</h6><p>在二叉搜索树中，这两个特殊的节点有特殊的名字：</p><ul><li>比 current 小一点点的节点，称为 current 节点的前驱。比如下图中的节点 5 就是节点 7 的前驱；</li><li>比 current 大一点点的节点，称为 current 节点的后继。比如下图中的节点 8 就是节点 7 的后继；</li></ul><p><img src="https://qn.huat.xyz/mac/20220829104418.png" alt="image"></p><p>查找需要被删除的节点 current 的后继时，需要在 current 的右子树中查找最小值，即在 current 的右子树中一直向左遍历查找；</p><p>查找前驱时，则需要在 current 的左子树中查找最大值，即在 current 的左子树中一直向右遍历查找。</p><p>下面只讨论查找 current 后继的情况，查找前驱的原理相同，这里暂不讨论。</p><p>代码实现：</p><div class="language-js"><pre><code>  <span class="token comment">// 3、删除的是有两个子节点的节点</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>

    <span class="token comment">// 1、找到后续节点</span>
    <span class="token keyword">let</span> successor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSuccessor</span><span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、判断是否为根节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、将后续的左节点改为被删除的左节点</span>
    successor<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取后续节点，即从要删除的节点的右边开始查找最小的值</span>
<span class="token function">getSuccessor</span><span class="token punctuation">(</span><span class="token parameter">delNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// 定义变量，保存要找到的后续</span>
  <span class="token keyword">let</span> successor <span class="token operator">=</span> delNode<span class="token punctuation">;</span>
  <span class="token keyword">let</span> current <span class="token operator">=</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token keyword">let</span> successorParent <span class="token operator">=</span> delNode<span class="token punctuation">;</span>

  <span class="token comment">// 循环查找 current 的右子树节点</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    successorParent <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    successor <span class="token operator">=</span> current<span class="token punctuation">;</span>
    current <span class="token operator">=</span> current<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 判断寻找到的后续节点是否直接就是要删除节点的 right</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>successor <span class="token operator">!==</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    successorParent<span class="token punctuation">.</span>left <span class="token operator">=</span> successor<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    successor<span class="token punctuation">.</span>right <span class="token operator">=</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> successor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="完整实现">完整实现</h5><div class="language-js"><pre><code><span class="token comment">// 删除节点</span>
<span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
  <span class="token keyword">let</span> parentNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> isLeftChild <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

  <span class="token comment">// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>key <span class="token operator">!==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    parentNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>

    <span class="token comment">// 小于，往左查找</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> currentNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isLeftChild <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">// 否则往右查找</span>
      isLeftChild <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 找到最后都没找到相等的节点，返回 false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span>


  <span class="token comment">// 1、删除的是叶子节点的情况</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> currentNode<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// 2、删除的是只有一个子节点的节点</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// currentNode 只存在左节点</span>
    <span class="token comment">//-- 2.1、currentNode 只存在&lt;左节点&gt;的情况</span>
    <span class="token comment">//---- 2.1.1、currentNode 等于 root</span>
    <span class="token comment">//---- 2.1.2、parentNode.left 等于 currentNode</span>
    <span class="token comment">//---- 2.1.3、parentNode.right 等于 currentNode</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// currentNode 只存在右节点</span>
    <span class="token comment">//-- 2.2、currentNode 只存在&lt;右节点&gt;的情况</span>
    <span class="token comment">//---- 2.1.1 currentNode 等于 root</span>
    <span class="token comment">//---- 2.1.1 parentNode.left 等于 currentNode</span>
    <span class="token comment">//---- 2.1.1 parentNode.right 等于 currentNode</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// 3、删除的是有两个子节点的节点</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>

    <span class="token comment">// 1、找到后续节点</span>
    <span class="token keyword">let</span> successor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSuccessor</span><span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、判断是否为根节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、将后续的左节点改为被删除的左节点</span>
    successor<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取后续节点，即从要删除的节点的右边开始查找最小的值</span>
<span class="token function">getSuccessor</span><span class="token punctuation">(</span><span class="token parameter">delNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// 定义变量，保存要找到的后续</span>
  <span class="token keyword">let</span> successor <span class="token operator">=</span> delNode<span class="token punctuation">;</span>
  <span class="token keyword">let</span> current <span class="token operator">=</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token keyword">let</span> successorParent <span class="token operator">=</span> delNode<span class="token punctuation">;</span>

  <span class="token comment">// 循环查找 current 的右子树节点</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    successorParent <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    successor <span class="token operator">=</span> current<span class="token punctuation">;</span>
    current <span class="token operator">=</span> current<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 判断寻找到的后续节点是否直接就是要删除节点的 right</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>successor <span class="token operator">!==</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    successorParent<span class="token punctuation">.</span>left <span class="token operator">=</span> successor<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    successor<span class="token punctuation">.</span>right <span class="token operator">=</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> successor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="平衡树">平衡树</h2><p>二叉搜索树的缺陷：当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树由 11 7 15 组成，如下图所示：</p><p><img src="https://qn.huat.xyz/mac/20220829104419.png" alt="image"></p><p>当插入一组有序数据：6 5 4 3 2 就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。</p><p><img src="https://qn.huat.xyz/mac/20220829104419.png" alt="image"></p><p>非平衡树</p><ul><li>比较好的二叉搜索树，它的数据应该是左右均匀分布的。</li><li>但是插入连续数据后，二叉搜索树中的数据分布就变得不均匀了，我们称这种树为非平衡树。</li><li>对于一棵平衡二叉树来说，插入/查找等操作的效率是 O(log n)。</li><li>而对于一棵非平衡二叉树来说，相当于编写了一个链表，查找效率变成了 O(n)。</li></ul><p>树的平衡性</p><p>为了能以较快的时间 O(log n)来操作一棵树，我们需要保证树总是平衡的：</p><ul><li>起码大部分是平衡的，此时的时间复杂度也是接近 O(log n) 的；</li><li>这就要求树中每个节点左边的子孙节点的个数，应该尽可能地等于右边的子孙节点的个数；</li></ul><p>常见的平衡树</p><ul><li>AVL 树：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于 AVL 树是平衡树，所以它的时间复杂度也是 O(log n)。但是它的整体效率不如红黑树，开发中比较少用。</li><li>红黑树：同样通过一些特性来保持树的平衡，时间复杂度也是 O(log n)。进行插入/删除等操作时，性能优于 AVL 树，所以平衡树的应用基本都是红黑树。</li></ul></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><!----></div></div><div class="updated" data-v-fb8d84c6><p class="last-updated" data-v-fb8d84c6 data-v-5797b537><span class="prefix" data-v-5797b537>上次更新:</span><span class="datetime" data-v-5797b537></span></p></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><a class="link" href="/huhushengwei-docs/algorithm/dataStructure/tree/二叉树" data-v-38ede35f><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-38ede35f><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-38ede35f>二叉树</span></a></div><div class="next" data-v-38ede35f><a class="link" href="/huhushengwei-docs/algorithm/search/1.冒泡排序" data-v-38ede35f><span class="text" data-v-38ede35f>1.冒泡排序</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-38ede35f><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"d3b452dc\",\"algorithm_index.md\":\"d3e5b4fb\",\"devtool_index.md\":\"f2b61841\",\"frame_index.md\":\"f343698d\",\"guide_index.md\":\"9614ca5c\",\"network_index.md\":\"6c5c98e1\",\"other_index.md\":\"6cf88c26\",\"other_interview.md\":\"644cbfe7\",\"performance_index.md\":\"590d92c3\",\"performance_项目优化.md\":\"117165ce\",\"workflow_index.md\":\"a15e237b\",\"algorithm_array_two-numbers-sum.md\":\"d6b117e6\",\"algorithm_linklist_js反转单向链表.md\":\"7291629c\",\"algorithm_search_1.冒泡排序.md\":\"928fea88\",\"algorithm_search_2.二分查找.md\":\"cc3e6931\",\"algorithm_search_3.插入排序.md\":\"0a923691\",\"algorithm_search_4.快速排序.md\":\"bb96932f\",\"algorithm_stack_用两个栈实现一个队列.md\":\"0bf631f4\",\"devtool_git_1.git 常用命令.md\":\"bed99cbb\",\"devtool_git_2.如何使用git管理项目.md\":\"c56d5c6b\",\"frame_react_1.hooks用过吗？聊聊react中class组件和函数组件的区别.md\":\"8821298f\",\"frame_react_2.react 组件通信方式.md\":\"12db9c52\",\"frame_react_3.setstate 既存在异步情况也存在同步情况.md\":\"0abfea6c\",\"frame_react_4.生命周期.md\":\"443c947a\",\"frame_react_5.说一下 react-fiber.md\":\"f1644bc9\",\"frame_react_6.portals.md\":\"4d9c6607\",\"frame_react_7.何时要使用异步组件？如和使用异步组件.md\":\"88753df9\",\"frame_react_8.react 事件绑定原理.md\":\"8a5ab171\",\"frame_vue_01-vue组件之间通信方式有哪些.md\":\"2c8ac08e\",\"frame_vue_02-v-if和v-for哪个优先级更高？.md\":\"966a1589\",\"frame_vue_03-简述 vue 的生命周期以及每个阶段做的事.md\":\"27a4da0f\",\"frame_vue_04-能说一说双向绑定使用和原理吗.md\":\"0eaa34dc\",\"frame_vue_05-vue中如何扩展一个组件.md\":\"a869ed90\",\"frame_vue_06-子组件可以直接改变父组件的数据么，说明原因.md\":\"bd5dac09\",\"frame_vue_07-vue要做权限管理该怎么做？控制到按钮级别的权限怎么做.md\":\"038c3869\",\"frame_vue_08 - 说一说你对vue响应式理解.md\":\"bcaf107d\",\"frame_vue_09 - 说说你对虚拟 dom 的理解？.md\":\"64a3428f\",\"frame_vue_10 - 你了解diff算法吗.md\":\"06a2f1b2\",\"frame_vue_11 - 你知道哪些vue3新特性.md\":\"8b2a3cd1\",\"frame_vue_12 - 怎么定义动态路由？怎么获取传过来的动态参数.md\":\"2ea962c9\",\"frame_vue_13-如果让你从零开始写一个vue路由，说说你的思路.md\":\"29fd9479\",\"frame_vue_14-能说说key的作用吗.md\":\"2c14a16d\",\"frame_vue_15-说说nexttick的使用和原理.md\":\"43c9a1df\",\"frame_vue_16-watch和computed的区别以及选择.md\":\"91bfd3e8\",\"frame_vue_17-说一下 vue 子组件和父组件创建和挂载顺序.md\":\"ebd6e2f1\",\"frame_vue_18-怎么缓存当前的组件？缓存后怎么更新？.md\":\"ee1f4fe1\",\"frame_vue_19-从0到1自己构架一个vue项目，说说有哪些步骤、哪些重要插件、目录结构你会怎么组织.md\":\"49754965\",\"frame_vue_20-实际工作中，你总结的vue最佳实践有哪些？.md\":\"8d2f38bc\",\"frame_vue_21 - 简单说一说你对vuex理解？.md\":\"c407a0a9\",\"frame_vue_22-说说从 template 到 render 处理过程.md\":\"03b20987\",\"frame_vue_23-vue实例挂载的过程中发生了什么.md\":\"f40be17e\",\"frame_vue_24 - vue 3.0的设计目标是什么？做了哪些优化.md\":\"519b2975\",\"frame_vue_25-你了解哪些vue性能优化方法.md\":\"78a5ce3d\",\"frame_vue_26-vue组件为什么只能有一个根元素.md\":\"cc155c12\",\"frame_vue_27-你有使用过vuex的module吗.md\":\"4dd02445\",\"frame_vue_28-怎么实现路由懒加载呢.md\":\"7c58f216\",\"frame_vue_29-ref和reactive异同.md\":\"7e4e3f43\",\"frame_vue_30-watch和watcheffect异同.md\":\"e807266a\",\"frame_vue_31-spa、ssr的区别是什么.md\":\"d05edee6\",\"frame_vue_32-你知道vue-loader吗.md\":\"4ebb5926\",\"frame_vue_33-你写过自定义指令吗？使用场景有哪些.md\":\"0f683cef\",\"frame_vue_34-说下$attrs和$listeners的使用场景.md\":\"b158170b\",\"frame_vue_35-v-once的使用场景有哪些.md\":\"797d7ce2\",\"frame_vue_36-什么是递归组件？举个例子说明下.md\":\"ca3df170\",\"frame_vue_37-异步组件是什么？使用场景有哪些.md\":\"570ebbf1\",\"frame_vue_38-你是怎么处理vue项目中的错误的.md\":\"21917869\",\"frame_vue_39-使用vue渲染大量数据时应该怎么优化？说下你的思路.md\":\"6e3c1d76\",\"frame_vue_40-如果让你从零开始写一个vuex，说说你的思路.md\":\"168a16f7\",\"frame_vue_41-vuex中actions和mutations有什么区别.md\":\"ef0fb729\",\"frame_vue_42-怎么监听vuex数据的变化.md\":\"481132ff\",\"frame_vue_43-router-link和router-view是如何起作用的.md\":\"2f6282fd\",\"frame_vue_44-vue-router 除了 router-link 怎么实现跳转.md\":\"70615c5f\",\"frame_vue_45-vue3.0 性能提升体现在哪些方面.md\":\"f410ca8b\",\"frame_vue_46-vue3.0里为什么要用 proxy 替代 defineproperty.md\":\"c5f48129\",\"frame_vue_47-history模式和hash模式有何区别.md\":\"d64b7384\",\"frame_vue_48-在什么场景下会用到嵌套路由.md\":\"0d11b1dc\",\"frame_vue_49-页面刷新后vuex的state数据丢失怎么解决.md\":\"4e5af585\",\"frame_vue_50-你觉得vuex有什么缺点.md\":\"c3479983\",\"frame_vue_51-composition api 与 options api 有什么不同.md\":\"dfedd9ae\",\"frame_vue_52-vue-router中如何保护路由.md\":\"bda8cde5\",\"guide_browser_1.cookie、sessionstorage、localstorage 的区别.md\":\"3ea778f6\",\"guide_browser_2.从输入url到页面加载的全过程.md\":\"037e3a9a\",\"guide_browser_3.浏览器重绘与重排的区别.md\":\"aacb4d7e\",\"guide_browser_4.如何触发重排和重绘.md\":\"44c43350\",\"guide_browser_5.如何避免重绘或者重排.md\":\"a13c3b80\",\"guide_browser_6.介绍下304过程.md\":\"3bc3d0c2\",\"guide_browser_7.浏览器的缓存机制 强制缓存 && 协商缓存.md\":\"d87fc26f\",\"guide_browser_8.说下进程、线程和协程.md\":\"77c30bab\",\"guide_func_1.格式化金额.md\":\"e434910c\",\"guide_html&css_1.html5 新特性、语义化.md\":\"97d20212\",\"guide_html&css_10.页面布局.md\":\"c3eab22c\",\"guide_html&css_11.如何使用rem或viewport进行移动端适配.md\":\"aa971473\",\"guide_html&css_12.清除浮动的方式.md\":\"56c02126\",\"guide_html&css_2.css 选择器及优先级.md\":\"45001443\",\"guide_html&css_3.position 属性的值有哪些及其区别.md\":\"c1839092\",\"guide_html&css_4.box-sizing属性.md\":\"aa567823\",\"guide_html&css_5.css 盒子模型.md\":\"babc272c\",\"guide_html&css_6.bfc（块级格式上下文）.md\":\"b4bd6b50\",\"guide_html&css_7.让一个元素水平垂直居中.md\":\"39e5c7f8\",\"guide_html&css_8.隐藏页面中某个元素的方法.md\":\"606d019c\",\"guide_html&css_9.用css实现三角符号.md\":\"a4e09c4e\",\"guide_js_1.js中的8种数据类型及区别.md\":\"224020e7\",\"guide_js_10.eventloop 事件循环.md\":\"1d16c02e\",\"guide_js_11.settimeout、promise、async、await 的区别.md\":\"2ab70a7d\",\"guide_js_12.async、await 如何通过同步的方式实现异步.md\":\"099095b9\",\"guide_js_13.介绍节流防抖原理、区别以及应用.md\":\"af954b49\",\"guide_js_2.js中的数据类型检测方案.md\":\"d0d77842\",\"guide_js_3.var && let && const.md\":\"c31e126b\",\"guide_js_4.js垃圾回收机制.md\":\"38208cec\",\"guide_js_5.作用域和作用域链.md\":\"cc205f6f\",\"guide_js_6.闭包的两大作用：保存、保护.md\":\"a0145aeb\",\"guide_js_7.js 中 this 的五种情况.md\":\"9cbb12be\",\"guide_js_8.原型 && 原型链.md\":\"34cbc2e4\",\"guide_js_9.new运算符的实现机制.md\":\"5130bc2d\",\"network_http_1.http 和 https.md\":\"e2eef06b\",\"network_http_2.http 请求跨域问题.md\":\"b2d7a1ac\",\"network_tcp_1.tcp三次握手.md\":\"24afc9d2\",\"network_tcp_2.tcp 四次挥手.md\":\"e8daf9a7\",\"network_tcp_3.tcp如何保证数据包传输的有序可靠.md\":\"c95f304e\",\"network_tcp_4.tcp和udp的区别.md\":\"9cce1a9e\",\"network_tcp_5.粘包问题分析与对策.md\":\"2cde0382\",\"workflow_babel_1.简单描述一下 babel 的编译过程.md\":\"799aae73\",\"workflow_deploy_部署.md\":\"f44dfd5a\",\"workflow_vite_01-你对vite的理解.md\":\"2078d62b\",\"workflow_webpack_1.webpack 做过哪些优化，开发效率方面、打包策略方面等等.md\":\"a0e28ba3\",\"algorithm_datastructure_linklist_单向链表.md\":\"abf02f4e\",\"algorithm_datastructure_linklist_双向链表.md\":\"d591dfda\",\"algorithm_datastructure_queue_优先队列.md\":\"3f5f6639\",\"algorithm_datastructure_queue_队列.md\":\"9b7e522f\",\"algorithm_datastructure_stack_1.栈.md\":\"c8c1772e\",\"algorithm_datastructure_tree_二叉搜索树.md\":\"75134e03\",\"algorithm_datastructure_tree_二叉树.md\":\"d629e1ba\",\"algorithm_datastructure_tree_树.md\":\"af8033f0\"}")</script>
    <script type="module" async src="/huhushengwei-docs/assets/app.157864df.js"></script>
  </body>
</html>